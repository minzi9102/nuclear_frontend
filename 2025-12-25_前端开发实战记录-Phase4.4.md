# 📝 开发实战记录：治疗部位翻译与规范化

## 开发目标
本次开发的目标是实现全系统内治疗部位从"后端英文枚举"到"前端中文显示"的转换，并建立一套标准化的常量管理机制。

## 1. 核心架构：建立单一事实来源 (Single Source of Truth)

为了避免在多个组件中重复写死翻译逻辑，首先在 `src/constants/treatment.ts` 中建立了中心化的常量池：

- **翻译映射表 (TREATMENT_TARGET_MAP)**：定义了从 Strapi 后端枚举值到中文标签的 1:1 映射。
- **选项数组 (TARGET_OPTIONS)**：通过 `Object.entries` 自动生成的对象数组，专供下拉选择器 (`el-select`) 使用，确保 Label 和 Value 始终匹配。

## 2. 类型增强：实现类型安全 (Type Safety)

在 `src/api/types.ts` 中，摒弃了手动维护字符串联合类型的方式：

- **动态推导**：利用 TypeScript 的 `keyof typeof` 特性，从常量映射表的键名中自动推导 `TreatmentTarget` 类型。
- **效果**：当常量表更新时，全系统的代码补全和类型检查会自动同步，无需手动修改类型定义。

## 3. UI 适配：全系统多点应用

在各业务模块中引入常量并实现翻译展示：

### 治疗记录列表 (views/treatments/index.vue)
- **表格**：使用自定义插槽，通过 `TREATMENT_TARGET_MAP[row.target]` 渲染中文。
- **表单**：将 `el-option` 绑定至 `TARGET_OPTIONS`，实现"选中文，存英文"。

### 患者管理卡片 (views/patients/index.vue)
- 在"最近治疗"栏位通过映射表显示中文部位。

### 详情弹窗 (components/TreatmentDetailDialog.vue)
- 在详情顶部的 `el-tag` 处实现翻译转换。

## 🐛 遇到的问题与解决方案 (Troubleshooting)

| 问题现象 (Symptom) | 根本原因 (Root Cause) | 解决方案 (Solution) |
|---|---|---|
| 多处维护成本高 | 部位名称在多个组件中硬编码，修改一处需同步修改多处。 | 常量化管理：将所有部位定义提取到 `src/constants/treatment.ts`。 |
| 类型定义不同步 | `types.ts` 里的类型与实际映射表可能不一致，导致 IDE 无法准确纠错。 | 动态推导类型：使用 `export type TreatmentTarget = keyof typeof TREATMENT_TARGET_MAP`。 |
| 提交数据非法 | Strapi 后端枚举字段只接受英文，如果前端直接传中文会导致 400 错误。 | Label/Value 分离：下拉框显示 label (中文)，但 `v-model` 绑定 value (英文)。 |
| 数据渲染不确定性 | 如果后端返回了映射表之外的旧数据，前端可能显示为空。 | 防御性渲染：使用 `TREATMENT_TARGET_MAP[key] || '未知部位'` 确保始终有备选显示。 |

## 💡 核心经验总结

1. **规范优于实现**：通过 `constants + types` 的联动，将原本散落在业务代码中的硬编码逻辑转化为了受 TypeScript 保护的配置项。

2. **前后端解耦**：前端保留了对原始英文 Key 的处理能力，通过"翻译层"将其转为对用户友好的中文，而不需要后端改动数据库结构。
