# iOS 图片上传旋转问题完整复盘 (Phase 4.7)

这是一个非常扎实的技术攻坚过程。我们从最初的"图片方向不对"，到"过度修正"，再到"所见非所得"，最后通过**像素重绘（Pixel Baking）**彻底解决了 iOS 移动端上传图片的顽疾。

以下是关于 iOS 图片上传旋转问题 及其配套流程改造的完整复盘总结：

## 一、 核心问题：为什么 iOS 拍照会旋转？

### 现象
在 iPhone/iPad 上拍照上传后，预览看着是正的，但上传到服务器并在列表页显示时，图片往往旋转了 90 度或 180 度。

### 原理
iOS 为了拍照速度，相机传感器始终按"横屏"模式记录数据。如果用户竖屏拍照，iOS 不会旋转像素，而是给图片打上一个 EXIF Orientation 标记（告诉显示设备"请旋转 90 度显示我"）。

### 坑点
- **浏览器预览**：Safari/Chrome 读取 Blob 时会自动应用 EXIF，所以预览是正的（视觉欺骗）。
- **后端存储**：上传的是原始二进制流（物理像素是躺着的）。如果后端或列表页组件不识别 EXIF，图片就会打回原形。

## 二、 解决过程与演进

### 阶段 1：尝试自动修正 (Compressor.js)
- **尝试**：引入 compressorjs 插件，设置 `checkOrientation: true`。
- **问题**：插件不起作用
- **结论**：完全依赖自动算法不可靠，需要人工介入 + 强制清洗。

### 阶段 2：交互流程重构 (延迟上传)
- **需求**：为了支持医生手动旋转修正，不能一选图就上传。
- **改造**：
  - 将 `el-upload` 改为 `auto-upload="false"`。
  - 组件内部维护 `localFileList`，仅在前端进行图片处理。
  - 父组件点击"确认创建"时，调用 `submitAll()` 批量上传。

### 阶段 3：终极方案——"像素固化" (Pixel Baking)
- **问题**：即使在预览弹窗里看着是正的，上传后列表页还是歪的。
- **原因**：预览用的是 `<img>` 标签（浏览器处理了 EXIF），但上传传的是 File 原件（带 EXIF 的歪图）。
- **解决**：
  - 利用 Canvas 的 `drawImage` 方法。
  - 将浏览器渲染好的（视觉正确的）Image 对象画到画布上。
  - 即使不旋转（角度0），也要重绘。
  - **效果**：Canvas 导出的是纯像素数据，EXIF 被剥离，物理像素被永久"扶正"。

## 三、 遇到的关键问题 (Bug) 与 解决方案 (Fix)

| 问题分类 | 具体表现 | 原因分析 | 解决方案 |
|--------|--------|--------|--------|
| 旋转逻辑 | 插件不起作用（仍然自动颠倒） | 插件不起作用。 | 禁用插件的自动修正，或者依靠 Canvas 重绘接管控制权。 |
| 特殊场景 | 俯拍（拍伤口）方向随机 | 手机平行地面时，陀螺仪无法判断方向（万向节死锁）。 | 增加"手动旋转"按钮。允许用户在上传前预览并点击按钮修正方向。 |
| TypeScript | Object is possibly undefined | 数组索引访问 `list[index].url` 被 TS 认为可能为空。 | 使用 计算属性 (Computed) `currentFile` 统一处理空值检查，或使用可选链 `?.`。 |
| 异步陷阱 | 上传的文件大小为 0 字节 | `processRotation` 中图片还没加载完（onload前）就绘制了 Canvas。 | 增加 `fileToImage` 辅助函数，强制 `await img.onload` 确保图片就绪后再绘图。 |
| 后端报错 | API 返回 400 Bad Request | Strapi 报错 Invalid key data。 | 双重封装问题。API 函数封装了一层 `{data: ...}`，组件调用时又封装了一层。解包即可。 |
| 画质损耗 | 图片模糊 | compressorjs 和 Canvas 导出默认会有压缩（默认 0.8）。 | 将 Canvas 导出质量参数 (encoderOptions) 和插件参数显式设为 1.0。 |

## 四、 最终代码逻辑流程图

这是我们最终确定的稳定逻辑：

```
用户选图/拍照 ⬇️

Step 1: 预处理 (HandleFileChange)
  ├─ 动作：直接读取文件。
  ├─ 动作：await fileToImage(file) 
  │         (让浏览器解析 EXIF 并生成视觉正确的 Image 对象)
  └─ 关键：await processRotation(img, 0) 
           (像素清洗/固化：把视觉正确的图像"烧录"进像素，去除 EXIF)
    ⬇️

Step 2: 本地预览
  ├─ 显示清洗后的图片。
  └─ 用户发现方向不对？ -> 点击 [旋转] 按钮。
     └─ 动作：await processRotation(img, 90) -> 替换本地文件。
    ⬇️

Step 3: 父组件提交
  ├─ 用户点击"确认创建"。
  ├─ 动作：父组件调用 uploaderRef.value.submitAll()。
  └─ 动作：子组件并发上传图片 -> 返回 ID 数组 [101, 102]。
    ⬇️

Step 4: 数据写入
  ├─ 父组件将 [101, 102] 填入 Payload。
  └─ 发送 createTreatment 请求。
```

## 五、 总结与建议

通过这次重构，你的 Hospital CMS 在移动端的可靠性提升了一个台阶。

### 数据层面
保证了"所见即所得"，彻底消除了跨平台（iOS vs Android vs PC）显示不一致的隐患。

### 交互层面
从"黑盒自动上传"变成了"用户可控的所见即所得"，更符合医疗严谨性的要求。

### 隐私层面
坚持使用浏览器 input 调起相机，不保存照片到医生私人相册，符合合规要求。

### 后续建议
目前的 `submitAll` 是并发上传，如果医生一次拍了 10 张高清图，可能会阻塞网络。如果后续遇到卡顿，可以考虑改为"队列上传"（一张传完再传下一张）并增加进度条。目前暂时够用。
