# 前端开发实战记录 - Phase 1：环境搭建与基础配置

日期：2025年12月01日
项目名称：hospital-cms (治疗效果记录管理平台)
技术栈：Vue 3 + TypeScript + Vite + Element Plus + Pinia + Axios

## 1. 🚀 操作步骤记录

### 1.1 初始化项目

使用 Vite 脚手架快速生成 Vue 3 + TypeScript 项目模板。
```bash
# 在目标目录下创建项目
npm create vite@latest hospital-cms -- --template vue-ts
```

### 1.2 安装核心依赖

安装项目所需的 UI 库、路由、状态管理和网络请求库。
```bash
cd hospital-cms
npm install element-plus axios pinia vue-router
```

### 1.3 基础文件配置

*   `src/router/index.ts`：创建了基础路由文件，暂时指向登录页。
*   `src/main.ts`：在入口文件中挂载了 Element Plus、Pinia 和 Router。

### 1.4 🧪 核心任务：Axios 封装 (src/utils/request.ts)

为了统一处理前后端交互，封装了 Axios 实例：

*   `BaseURL`：配置为 `http://localhost:1337/api` (Strapi 后端地址)。
*   **请求拦截器**：自动从 `localStorage` 读取 JWT Token 并加入 Header (`Authorization: Bearer <token>`)。
*   **响应拦截器**：全局处理错误，特别是 `401 Unauthorized` 状态下自动清除缓存并跳转回登录页。

## 2. 🐛 遇到的问题与解决方案 (Troubleshooting)

在配置过程中遇到了 3 个主要错误，均已解决。

### 🔴 问题一：找不到路由模块

报错信息：
```
找不到模块“../router”或其相应的类型声明。ts(2307)
```
原因分析：utils文件夹放错了位置，导致相对路径引用错误。

✅ 解决方案： 将utils文件夹放在src文件夹下，而不是与src同级

### 🔴 问题二：Axios 类型导入错误

报错信息：
```
“AxiosInstance”是一种类型，必须在启用 "verbatimModuleSyntax" 时使用仅类型导入进行导入。ts(1484)
```
原因分析： Vite 默认开启了 `verbatimModuleSyntax` 规则。TypeScript 要求在导入“纯类型”（在编译后会被删除的代码）时，必须使用 `import type` 语法，而 axios 是实体对象，不能混在一起导入。

✅ 解决方案： 将导入语句拆分为“实体导入”和“类型导入”：
```typescript
// 修改前
import axios, { AxiosInstance, ... } from 'axios'

// 修改后
import axios from 'axios' // 导入功能
import type { AxiosInstance, AxiosError, ... } from 'axios' // 导入类型定义
```

### 🔴 问题三：无法启动项目 (ENOENT)

报错信息：
```
npm error code ENOENT Could not read package.json
```
原因分析： 在执行 `npm run dev` 时，当前所在的目录是项目的父级文件夹，而不是项目文件夹本身。npm 找不到 `package.json` 配置文件。

✅ 解决方案： 进入项目文件夹后再运行命令：
```bash
# 查看当前目录下的文件夹
dir

# 进入项目文件夹
cd hospital-cms

# 再次安装依赖（保险起见）并启动
npm install
npm run dev
```

## 3. 🎉 阶段成果

*   ✅ Node.js 环境验证通过。
*   ✅ Vue 3 项目骨架搭建完成。
*   ✅ 核心依赖库安装完毕。
*   ✅ Axios 网络请求层封装完毕（含 Token 拦截逻辑）。
*   ✅ 项目成功启动在 `http://localhost:5173`。

## 4. 验证该阶段成果是否达成预期目标

验证 Phase 1（环境与基础）是否成功的最佳方式，是进行一次**“冒烟测试” (Smoke Test)**。

我们需要验证三件事：

*   Element Plus 样式是否加载成功？
*   Axios 能否发请求？
*   拦截器 是否真的把 Token 塞进了请求头？

请按照以下步骤，修改 `src/App.vue` 文件进行临时测试。

🧪 第一步：编写测试代码

请打开 `src/App.vue`，完全清空里面的内容，粘贴以下代码。

这段代码做了两件事：

*   放了一个 Element Plus 的按钮（测试 UI）。
*   在页面加载时，手动存入一个假 Token，并尝试发一个请求（测试 Axios）。

代码段

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import request from './utils/request' // 引入我们封装的 axios

onMounted(async () => {
  // 1. 模拟登录：手动往 localStorage 存一个假的 token
  localStorage.setItem('jwt', 'test-fake-token-123456')
  console.log('✅ 已存入测试 Token')

  try {
    // 2. 发起一个请求 (请求 Strapi 的默认公开接口，或者故意请求一个不存在的接口)
    // 这里我们请求 /users/me，通常这需要权限，正好测试 401/403 拦截器
    // 或者请求一个不存在的地址测试 404
    const res = await request.get('/users/me')
    console.log('请求成功:', res)
  } catch (error) {
    console.log('❌ 请求被拦截器捕获 (这是预期的):', error)
  }
})
</script>

<template>
  <div style="padding: 50px; text-align: center;">
    <h1>Phase 1 验证页面</h1>
    <el-button type="primary" size="large">
      如果你看到我是蓝色的，说明 Element Plus 配置成功
    </el-button>
  </div>
</template>

<style>
/* 简单的居中样式 */
body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}
</style>
```

🔍 第二步：在浏览器中验证

*   确保终端里 `npm run dev` 正在运行。
*   打开浏览器访问 `http://localhost:5173`。
*   按 `F12` 打开开发者工具 (`DevTools`)。

✅ 验证点 1：UI 库是否生效

*   看页面：你是否看到了一个蓝色的、圆角的大按钮？
*   判断：如果按钮是蓝色的，说明 Element Plus 样式引入成功。如果只是普通的灰色直角按钮，说明 `main.ts` 里的样式引入有问题。

✅ 验证点 2：请求拦截器 (Token 注入)

这是最关键的一步。

*   在开发者工具中，切换到 `Network (网络)` 标签页。
*   刷新页面。
*   在 `Network` 列表中找到名为 `me` (或者你请求的路径) 的红色请求。
*   点击这个请求，在右侧查看 `Headers (标头) -> Request Headers (请求标头)`。
*   检查：你能找到一个叫 `Authorization` 的字段吗？它的值是 `Bearer test-fake-token-123456` 吗？
    *   成功：说明你的 `request.ts` 里的请求拦截器工作完美！它自动读取了本地缓存并加上了头。

✅ 验证点 3：响应拦截器 (错误处理)

*   看页面顶部是否弹出了一个红色的提示框 (`Message`)？
    *   提示内容可能是“登录已过期”或“Forbidden”或“Not Found”。
*   判断：
    *   如果你用了假 Token 请求 `/users/me`，Strapi 后端会返回 `401` 或 `403`。
    *   如果页面弹出了红色的 `ElMessage` 提示框，说明你的响应拦截器成功捕获了错误并进行了反馈。
    *   如果你刚才在 `request.ts` 里写了 `router.push('/login')`，你甚至会发现浏览器的地址栏变成了 `http://localhost:5173/login`。

    ![2025-12-1-140243.png](assets/2025-12-01_前端开发实战记录-Phase1/2025-12-1-140243.png)

🧹 第三步：清理现场

验证全部通过后，说明地基非常牢固。请执行以下清理操作，为 Phase 2 做准备：

*   还原 `App.vue`：将 `App.vue` 恢复成最简单的 `<router-view />`，以便后面由路由控制页面显示。

修改 `src/App.vue` 为：
代码段

```vue
<script setup lang="ts">
</script>

<template>
  <router-view />
</template>

<style>
/* 全局样式重置，可选 */
html, body, #app {
  height: 100%;
  margin: 0;
  padding: 0;
}
</style>
```

*   清除假 Token：

    *   在浏览器控制台 (`Console`) 输入：`localStorage.clear()` 并回车。


# **📝 前端开发实战记录 - Phase 2：核心页面框架构建**

日期：2025-12-01  
阶段名称：Phase 2 - 核心页面框架构建  
任务目标：完成用户登录流程、搭建系统主布局（侧边栏+顶部导航）、配置嵌套路由，确保系统"骨架"搭建完毕。

---

## **1. 🏗️ 核心功能实现记录**

### **1.1 目录结构规划**

为了规范页面管理，建立了标准的视图层级：

* `src/views/login/`：存放登录页组件。
* `src/views/layout/`：存放系统主框架组件（侧边栏、顶栏）。
* `src/views/home/`：存放系统首页（仪表盘）组件。

### **1.2 登录流程开发**

**UI 实现**：使用 `<el-card>` 构建卡片式登录界面，集成 Element Plus 表单验证。

**逻辑实现**：
* 调用 POST /auth/local 接口进行身份验证。
* 关键动作：登录成功后，将 jwt (Token) 和 user (用户信息) 分别存入 localStorage。
* 跳转逻辑：验证通过后自动跳转至 / (即首页)。

### **1.3 主布局 (Layout) 开发**

**布局结构**：采用经典的后台管理布局（左侧固定菜单 + 顶部导航 + 右侧内容区）。

**组件使用**：使用 `<el-container>`, `<el-aside>`, `<el-header>`, `<el-main>` 构建整体框架。

**侧边栏菜单**：
* 配置 `<el-menu router>` 模式，实现点击菜单项自动跳转路由。
* 引入 `@element-plus/icons-vue` 图标库增强视觉体验。

**顶部导航**：实现了"退出登录"功能（清除 Token 并跳转回登录页）。

### **1.4 路由系统升级（嵌套路由）**

将路由从"单层结构"升级为"嵌套结构（Parent-Child）"：

* **`/login`**：独立路由，全屏显示登录页。
* **`/`（Layout）**：
  * 作为父路由，加载 Layout 组件（相框）。
  * **`/home`**：作为子路由，加载 Home 组件（画），显示在 Layout 的 `<router-view />` 中。

**路由守卫**：全局拦截无 Token 的访问，强制重定向至 `/login`。

---

## **2. 🐛 遇到的问题与解决方案 (Troubleshooting)**

### **🔴 问题一：TypeScript 类型导入报错**

**报错信息**：  
"RouteRecordRaw"是一种类型，必须在启用 "verbatimModuleSyntax" 时使用仅类型导入进行导入。

**原因**：  
Vite 默认开启严格模式，TS 不允许将"类型定义"和"功能函数"混写在同一个 import 语句中。

**✅ 解决方案**：  
在 `src/router/index.ts` 中拆分导入语句：

````typescript
import { createRouter, createWebHistory } from 'vue-router' // 导入功能
import type { RouteRecordRaw } from 'vue-router'            // 导入类型
````

---

### **🔴 问题二：Firefox 浏览器无法打开（Upgrade Required）**

**报错信息**：  
页面白屏或显示 Upgrade Required (HTTP 426)，但在 Edge/Chrome 下正常。

**原因**：  
Vite 开发服务器默认监听 `localhost`，而 Windows 下的 Firefox 对 IPv6/IPv4 解析机制较为严格，导致 WebSocket 热更新连接握手失败。

**✅ 解决方案**：  
修改 `vite.config.ts`，强制开发服务器绑定到 IPv4 地址：

````typescript
export default defineConfig({
  plugins: [vue()],
  server: {
    host: '127.0.0.1', // 强制使用 IPv4
    port: 5173,
  }
})
````

*注意：修改配置后必须重启终端*（Ctrl + C → `npm run dev`）*才能生效。*

---

### **🔴 问题三：登录后界面缺失菜单（高度塌陷）**

**现象**：  
登录后只显示了首页内容，左侧菜单栏和顶部导航栏消失（或高度为 0）。

**原因**：  
Vue 的根节点 `#app` 和 `body` 默认高度由内容撑开。如果内容很少，容器高度不足 100%，导致 Flex 布局的侧边栏无法撑满屏幕。

**✅ 解决方案**：  
在 `src/App.vue` 中强制设置全局高度：

````css
html, body, #app {
  height: 100%; /* 关键：必须占满屏幕 */
  margin: 0;
  padding: 0;
  width: 100%;
}
````

---

### **🔴 问题四：VSCode 误报"找不到模块 ts(2307)"**

**现象**：  
在 Vue 3 + TypeScript 项目中，编写路由或组件引入代码时，出现以下报错：

```
找不到模块"../views/home/index.vue"或其相应的类型声明。ts(2307)
```

具体特征：
* 文件确实存在：在文件资源管理器中，该路径下的文件是真实存在的。
* 路径拼写正确：经过检查，文件名大小写和相对路径均无误。
* 部分正常：同一文件中的其他引入（如 login 或 layout）没有报错，唯独新建的这个文件报错。

**原因**：  
这是 VSCode 编辑器的 TypeScript 语言服务（TS Server）缓存不同步导致的常见问题。

* 当在编辑器打开的情况下新建文件或文件夹时，TS Server 偶尔未能及时监听到文件系统的变化。
* 导致它仍然认为该文件"不存在"，从而抛出错误的类型检查警告。
* 这不是代码本身的错误，而是编辑器的服务"卡顿"了。

**✅ 解决方案**：  
通过重启 VSCode 的 TypeScript 服务来强制刷新缓存。

操作步骤：

1. **打开命令面板**：
   * Windows/Linux：按下 Ctrl + Shift + P
   * Mac：按下 Cmd + Shift + P

2. **输入命令**：
   * 在输入框中输入：`Restart TS Server` （中文环境下可尝试搜"重启 TypeScript 服务器"）

3. **执行**：
   * 选中对应选项并回车。

4. **结果**：
   * 等待下方状态栏闪烁几秒后，红线报错即会自动消失。

**💡 经验总结**：  
在开发过程中，如果确认"路径没错"且"配置没错"（如 env.d.ts 已配置），但依然出现 ts(2307) 找不到模块的错误，请优先使用"重启 TS Server"大法，而不要盲目修改代码配置。

---

## **3. 🎉 阶段总结**

至此，**Phase 2 圆满完成**！✅

现在的系统具备了：

* **安全性**：进门要查"工牌"（Token）。
* **稳定性**：解决了浏览器兼容问题。
* **美观性**：拥有了标准的后台管理界面框架。

**🚀 下一步（Phase 3）**：进入最核心的业务开发——对接患者管理 (Patients) 模块，实现真实的增删改查。


# **📝 前端开发实战记录 - Phase 3.1：患者列表对接**

日期：2025-12-01

任务目标：实现患者数据的获取（Read）、列表展示、分页及搜索功能，打通 Vue 前端与 Strapi 后端的 API 通信。

---

## **1. 🏗️ 核心实现步骤 (Implementation)**

### **1.1 定义 TypeScript 类型 (src/api/types.ts)**

为了规范数据流，我们根据 Strapi v5 的文档定义了接口类型。

**特点**：Strapi v5 的响应结构变平了，不再像 v4 那样包裹在 attributes 里。

**定义**：
* `Patient`：实体结构（患者基本信息）
* `ApiResponse<T>`：通用响应壳（包含 data 和 meta）
* `PatientQueryParams`：查询参数（分页、过滤、排序）

### **1.2 封装 API 请求 (src/api/patient.ts)**

将 HTTP 请求逻辑与 UI 分离。

**对接接口**：GET /patients

**关键参数**：
* `pagination[page]`：当前页码
* `pagination[pageSize]`：每页数量
* `filters`：过滤条件
* `sort`：排序字段

### **1.3 构建列表页面 (src/views/patients/index.vue)**

**UI 组件**：
* 使用 `<el-card>` 布局，`<el-table>` 展示数据，`<el-pagination>` 处理分页。

**交互逻辑**：

* **fetchData()**：核心函数，负责调接口、解包数据。
* **搜索**：监听输入框，修改 filters 参数并重置页码。
* **删除**：预留了 `deletePatient` 调用逻辑（UI 已实现）。

### **1.4 路由配置 (src/router/index.ts)**

* 在 Layout 的 `children` 下新增 `path: 'patients'`。
* 将登录后的默认重定向从 `/home` 改为 `/patients`，方便调试。

---

## **2. 🐛 遇到的问题与解决方案 (Troubleshooting)**

这是本阶段最有价值的经验总结。

### **🔴 问题一："洋葱皮"数据解包错误**

**现象**：

* 页面加载图标一直转圈，控制台报错：`TypeError: can't access property "pagination", res.meta is undefined`。
* Vue 警告：`Invalid prop: Expected Array, got Object`。

**原因**：

* **认知偏差**：我们以为 `res` 就是数据数组。
* **事实真相**：`res` 是 Axios 的完整响应对象。
  * 第一层 `res.data`：是 HTTP 响应体（包含 Strapi 的 data 和 meta）。
  * 第二层 `res.data.data`：才是真正的患者列表数组。
  * 第二层 `res.data.meta`：才是分页信息。

**✅ 解决方案**：在 `fetchData` 中多剥一层"洋葱"：

````typescript
// ❌ 错误写法
// tableData.value = res.data

// ✅ 正确写法 (防御性编程)
if (res.data) {
    tableData.value = res.data.data || [] 
    total.value = res.data.meta?.pagination?.total || 0
}
````

---

### **🔴 问题二：TypeScript 类型定义冲突**

**现象**：

* IDE 爆红：类型"Patient[]"上不存在属性"data"。

**原因**：

* 我们在 `src/api/patient.ts` 里告诉 TS 这个接口返回的是 `ApiResponse<Patient>`（我们定义的结构）。
* 但实际代码中，`request.ts` 的拦截器可能没有处理这一层，导致 TS 认为 `res` 已经是数据了，但实际运行时它还是 Axios 对象。
* 编译器定义与运行时结构打架了。

**✅ 解决方案**：暂时使用 `any` 类型断言，告诉 TS "按我说的做，别管类型检查"：

````typescript
// 强制断言 res 为 any，以此访问 .data 属性
const res: any = await getPatientList(apiParams as any)
````

---

## **3. 💡 关键经验 (Key Takeaways)**

* **调试大法**：当数据出不来时，第一时间在 `fetchData` 里 `console.log(res)`，看控制台打印的真实 JSON 结构，永远不要盲目相信文档或记忆。

* **Strapi 结构**：Strapi 的标准返回通常是 `{ data: [...], meta: {...} }`，前端需要根据 Axios 拦截器的配置决定剥离几层。

* **API 权限**：永远记得在 Strapi 后台 **Settings -> Roles -> Public/Authenticated** 中勾选对应的 API 权限，并点击 Save。

---

## **🚀 下一步计划 (Next Step)**

现在列表页已经能够显示，接下来的任务是实现 "增"和"改"：

* **目标**：点击"新建患者"弹出一个对话框（Dialog）。
* **内容**：包含姓名、性别、生日的表单。
* **接口**：对接 POST /patients 和 PUT /patients/:id。

准备好继续了吗？我们可以开始写弹窗组件了！


# 📝 前端开发实战记录 - Phase 3：治疗记录管理 (Treatment)

**日期：** 2025年12月12日

**目标：** 实现治疗记录的增删改查，建立患者与治疗记录的一对多关联，并实现后端自动生成治疗序号。

**技术栈：** Vue 3 (Frontend) + Strapi v5 (Backend)

---

## 1. 🏗️ 后端构建 (Strapi v5)

由于早期开发环境的数据污染问题，本阶段首先执行了后端重建。

### 1.1 数据模型设计 (Schema)

**Collection Type: Treatment**

关键字段：

- **treatmentNo** (Short Text): 自动生成的编号（如"第1次"）。
- **sequence_number** (Integer): 用于计算的纯数字序号。
- **target** (Enumeration): 治疗部位。
- **Images** (Media): 图片（当前设为非必填）。
- **patient** (Relation): 关联到 Patient (Many-to-One)，设置为 Required (必填)。

### 1.2 核心业务逻辑：自动序号生成

利用 Strapi 的 Lifecycle Hooks (`beforeCreate`) 实现。

**文件路径:** `src/api/treatment/content-types/treatment/lifecycles.js`

**逻辑流程:**

1. 拦截创建请求，提取关联的 patient ID。
2. 兼容处理 Strapi 后台 (`connect/set` 数组) 和 API (`documentId` 字符串) 的不同数据格式。
3. 若获取到的是 Integer ID，先反查数据库获取 DocumentId。
4. 查询该患者名下 `sequence_number` 最大的记录（包含 Draft 状态）。
5. 计算 `nextSequence` 并格式化为 `treatmentNo` 写入数据库。

### 1.3 权限配置

在 Settings -> Roles -> Authenticated 中开放了 Treatment 的 `find`, `findOne`, `create`, `delete` 权限。

---

## 2. 💻 前端构建 (Vue 3)

### 2.1 API 封装 (src/api/treatment.ts)

- **查 (List):** 使用 `populate: 'patient'` 参数，确保返回数据中包含患者姓名。
- **删 (Delete):** 关键修正 —— 参数必须使用字符串类型的 `documentId`，而非整数 `id`。
- **增 (Create):** 提交数据结构需包裹在 `{ data: { ... } }` 中。

### 2.2 页面实现 (src/views/treatments/index.vue)

**列表页:**

- 使用 `el-table` 展示数据。
- 展示"关联患者"列（处理空值情况）。
- 搜索栏支持按 `treatmentNo` 模糊查询。

**新建弹窗:**

- 使用 `el-select` 的远程搜索 (remote method) 功能，调用 `getPatientList` 接口实时检索患者。
- 下拉框 `value` 绑定患者的 `documentId`。
- 表单提交后自动刷新列表，显示后端计算好的序号。

---

## 3. 🐛 踩坑与故障排除记录 (Troubleshooting Log)

这是本阶段最有价值的经验总结，针对 Strapi v5 的特性进行了大量适配。

### 🔴 问题一：ID 类型混淆导致删除失败

**现象：** 点击删除，弹出确认框后请求发送，但后端返回 404 或无反应，数据未删除。

**原因：** Strapi v5 的 REST API 默认强制使用字符串格式的 `documentId` 进行操作，而前端传了整数 `id`。

**✅ 解决：** 修改 API 定义和页面逻辑，将所有操作的主键从 `row.id` 改为 `row.documentId`。

### 🔴 问题二：自动编号逻辑报错 Invalid key sequenceNumber

**现象：** 创建记录时后端报错。

**原因：** 误以为 Strapi 会自动将字段转为驼峰命名，但 `schema.json` 中定义的是下划线 `sequence_number`。

**✅ 解决：** 查阅 Schema 文件，将代码中所有字段名统一修正为 `sequence_number`。

### 🔴 问题三：数据库查询报错 Undefined attribute level operator id

**现象：** 无法自动计算序号。

**原因：** 在 `lifecycles.js` 中，将包含对象的变量（如 `{ documentId: '...' }`）直接传给了查询过滤器，Strapi 无法解析。

**✅ 解决：** 增加数据提取逻辑，确保传给 `filters` 的是纯字符串或数字 ID。

### 🔴 问题四：自动编号失效 (提取不到 Patient ID)

**现象：** 日志提示"未找到关联 Patient"，跳过计算逻辑。

**原因：** Strapi 后台（Admin Panel）提交关联数据时，使用了 `{ connect: [...] }` 或 `{ set: [...] }` 结构，且对象中只包含 Integer id。

**✅ 解决：**

- 增强提取逻辑，同时兼容 `connect` 和 `set` 操作符。
- 增加"反查"步骤：如果提取到的是 Integer ID，先查 Patient 表换取 `documentId`，再进行后续操作。

### 🔴 问题五：Element Plus 警告 Invalid prop: type

**现象：** 浏览器控制台报 Vue Warn。

**原因：** `<el-tag>` 的 `type` 属性被赋值为空字符串 `""`。

**✅ 解决：** 修改三元表达式，将空字符串改为默认值 `'primary'`。

### 🔴 问题六：Postman / 前端 403 Forbidden

**现象：** 重建后端后，API 请求全部失败。

**原因：** 数据库重置，导致旧的 JWT Token 和用户失效。

**✅ 解决：**

- 在新后台创建新用户。
- 前端清除 LocalStorage 缓存。
- Postman 重新调用 Login 接口获取新 Token 并更新环境变量。

---

## 4. 💡 Strapi v5 核心经验

通过本次开发，我们确认了 Strapi v5 的几个关键最佳实践：

1. **DocumentId 优于 ID：** 在前端开发和 API 调用中，始终优先使用 `documentId`。
2. **Schema 为准：** 字段命名（驼峰还是下划线）永远以 `schema.json` 为准。
3. **防御性编程：** 在编写 Lifecycle Hooks 时，必须考虑到数据来源的多样性（API 调用 vs 后台界面操作），数据结构可能完全不同。

---

## 🚀 下一步计划

至此，核心的 CRUD 和关联业务已打通。接下来的 Phase 4 我们将攻克最后一个难点：

- **多图上传与展示：** 处理 `Images` 字段，实现前端上传图片到 Strapi，并在列表中预览。
